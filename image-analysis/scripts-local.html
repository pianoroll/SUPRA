
<script src="https://cdn.jsdelivr.net/npm/vega@4.4.0"></script>
<script src="https://cdn.jsdelivr.net/npm/vega-lite@3.0.0-rc12"></script>
<script src="https://cdn.jsdelivr.net/npm/vega-embed@3.29.1"></script>

{% include_relative renderjson.html %}
{% include_relative listeners.html %}

<script>
// vim: ts=3


//////////////////////////////
//
// printInfo --
//

function printInfo(analysis) {
	return;  // ignore for now
	var element = document.querySelector("#info");
	if (!element) {
		return;
	}
	var output = "";
	output += "<table>";

	var druid = analysis.DRUID;
	var tearcount = parseInt(analysis.EDGE_TEAR_COUNT);
	var badholes = parseInt(analysis.BAD_HOLE_COUNT);
	var shifts = 0;
	if (analysis.SHIFTS) {
		if (Array.isArray(analysis.SHIFTS)) {
			shifts = parseInt(analysis.SHIFTS[0]);
			
		}
	}

	var select = document.querySelector("select");
	if (select) {
		select.value = druid;
	}

	output += "<tr>";
	output += "<td>";
	output += "DRUID:";
	output += "</td>";
	output += "<td>";
	output += "<a target='_blank' href='/uv/?id=" + druid + "'>";
	output += druid;
	output += "</a>";
	output += "(";
	output += "<a target='_blank' href='/uv/?id=" + druid + "'>";
	output += "view image";
	output += "</a>";
	output += ")";
	output += "</td>";
	output += "</tr>";

	if (tearcount > 0) {
		var maxtear = -1;
		if (!analysis.TEARS) {
			maxtear = 0;
		}
		var treble_tears = analysis.TEARS.TREBLE_TEARS;
		var bass_tears = analysis.TEARS.BASS_TEARS;
		if (treble_tears) {
			treble_tears = treble_tears.TEAR;
		}
		if (bass_tears) {
			bass_tears = bass_tears.TEAR;
		}
		if (treble_tears && !Array.isArray(treble_tears)) {
			treble_tears = [ treble_tears ];
		}
		if (bass_tears && !Array.isArray(bass_tears)) {
			bass_tears = [ bass_tears ];
		}
		var tears = [];
		if (treble_tears) {
			tears = tears.concat(treble_tears);
		}
		if (bass_tears) {
			tears = tears.concat(bass_tears);
		}
		for (var j=0; j<tears.length; j++) {
			var testtear = parseInt(tears[j].WIDTH_COL) / 300.0;
			testtear = parseInt(Math.abs(testtear) * 100.0 + 0.5) / 100.0;
			if (testtear > maxtear) { 
				maxtear = testtear;
			}
		}

		output += "<tr>";
		output += "<td>";
		output += "Edge tears:"
		output += "</td>";
		output += "<td>";
		output += tearcount;
		output += ", maximum depth: ";
		output += maxtear;
		output += " inches";
		output += " (magenta colored boxes)";
		output += "</td>";
		output += "</tr>";
	}

	if (badholes > 0) {
		output += "<tr>";
		output += "<td>";
		output += "Suspicious holes:"
		output += "</td>";
		output += "<td>";
		output += badholes;
		output += " (green colored circles)";
		output += "</td>";
		output += "</tr>";
	}

	if (shifts > 0) {
		output += "<tr>";
		output += "<td>";
		output += "Shifts:"
		output += "</td>";
		output += "<td>";
		output += shifts;
		output += " (vertical cyan lines)";
		output += "</td>";
		output += "</tr>";
	}

	output += "</table>";
	element.innerHTML = output;
}



//////////////////////////////
//
// displaySvgImage --
//

function displaySvgImage(analysis) {
	var element = document.querySelector("#image");
	if (!element) {
		return;
	}
	var output = "";

	var image_width = parseInt(analysis.IMAGE_LENGTH);
	var image_height = parseInt(analysis.IMAGE_WIDTH);
	var iw = parseInt(image_width);
	var ih = parseInt(image_height);

	output += "<svg style='height:100%'";
	output += " viewBox='0 0 " + iw + " " + ih + "'";
	output += "'>\n";

	// Draw a light gray box for the full image region:
	var scancolor = "#f0f0f0";
	output += addRect(0, 0, iw, ih, scancolor);

	var preleader_row = parseInt(analysis.PRELEADER_ROW);
	var leader_row = parseInt(analysis.LEADER_ROW);
	var hard_bass = parseInt(analysis.HARD_MARGIN_BASS);
	var hard_treble = parseInt(analysis.HARD_MARGIN_TREBLE);
	var rolltype = analysis.ROLL_TYPE;
	var papercolor = "#aaaaaa";
	if (rolltype.match(/welte/i) && rolltype.match(/red/i)) {
		papercolor = "#bb0033";
	}
	output += addRect(leader_row, hard_treble, image_width-leader_row, ih - hard_treble - hard_bass, papercolor);

	// draw paper outline
	var path = "";
	path += leader_row + "," + hard_treble + " ";
	path += iw + "," + hard_treble + " ";
	path += iw + "," + (ih - hard_bass) + " ";
	path += leader_row + "," + (ih - hard_bass) + " ";
	path += preleader_row + "," + ((ih - (hard_bass + hard_treble))/2) + " ";
	path += leader_row + "," + hard_treble;
	output += addPolygon(path, papercolor);

	// draw music region
	var first_hole = parseInt(analysis.FIRST_HOLE);
	var last_hole = parseInt(analysis.LAST_HOLE);
	var musiccolor = "#888888";
	if (rolltype.match(/welte/i) && rolltype.match(/red/i)) {
		musiccolor = "#990011";
	}
	var x = first_hole;
	var y = hard_treble;
	var w = last_hole - first_hole;
	var h = ih - hard_bass - hard_treble;
	output += addRect(x, y, w, h, musiccolor);

	output += printShifts(analysis);
	output += printBadHoles(analysis);
	output += printTears(analysis);
	output += printMusicNotes(analysis);

	output += "</svg>";

	// console.log("output", output);
	element.innerHTML = output;
}



//////////////////////////////
//
// printShifts --
//

function printShifts(analysis) {
	var output = "";
	var SHIFTS = analysis.SHIFTS;
	if (!SHIFTS) {
		return output;
	}
	if (!Array.isArray(SHIFTS)) {
		return output;
	}
	var shifts = SHIFTS[1].SHIFT;
	if (!shifts) {
		return output;
	}
	if (!Array.isArray(shifts)) {
		shifts = [ shifts ];
	}

	var shiftcolor = "#00ffff;";
	var iw = parseInt(analysis.IMAGE_WIDTH);
	var movement;
	// make vertical line more visible:
	var mfactor = 3;
	var x;
	for (var i=0; i<shifts.length; i++) {
		movement = Math.abs(parseInt(shifts[i].MOVEMENT));
		x = parseInt(shifts[i].ROW);
		output += "<line x1='" + x + "' y1='" + 0 + "' x2='" + x + "'y2='" + iw + "' ";
		output += "style='";
		output += "stroke: " + shiftcolor + "stroke-width: " + (movement*mfactor);
		output += "' />\n";
	}

	return output;
}



//////////////////////////////
//
// printMusicNotes --
//

function printMusicNotes(analysis) {
	var output = [];
	var holes = analysis.HOLES.HOLE;
	if (!holes) {
		return;
	}
	var iw = parseInt(analysis.IMAGE_WIDTH);
	var x, y, h, w;
	var ontime, offtime;
	var notecolor = "#000000;";

	var count = 0;
	for (var i=0; i<holes.length; i++) {
		if (!holes[i].NOTE_ATTACK) {
			continue;
		}
		count++;
		ontime = parseInt(holes[i].NOTE_ATTACK);
		offtime = parseInt(holes[i].OFF_TIME);
		x = parseInt(holes[i].ORIGIN_ROW);
		y = iw - parseInt(holes[i].ORIGIN_COL);
		w = offtime - ontime;
		h = parseInt(holes[i].WIDTH_COL);
		output.push(addRect(x, y, w, h, notecolor, null, "fill-opacity='0.25'"));
	}

	console.log("NOTE COUNT ON ROLL", count);

	return output.join("\n");
}



//////////////////////////////
//
// printBadHoles --
//

function printBadHoles(analysis) {
	var output = "";
	if (!analysis.BADHOLES) {
		return output;
	}
	var holes = analysis.BADHOLES.HOLE;
	if (!Array.isArray(holes)) {
		holes = [ holes ];
	}
	// var x, y, w, h;
	var cx, cy;
	var iw = parseInt(analysis.IMAGE_WIDTH);
	var badcolor = "#00ff00;";
	// Make large enough to see:
	var radius = 50;
	for (var i=0; i<holes.length; i++) {
		// x = parseInt(holes[i].ORIGIN_ROW);
		// y = parseInt(holes[i].ORIGIN_COL);
		// output += addRect(x, y, w*40, h*40, badcolor, badcolor);
		cx = parseInt(holes[i].CENTROID_ROW);
		cy = iw - parseInt(holes[i].CENTROID_COL);
		output += addCircle(cx, cy, radius, badcolor);
	}
	return output;
}



//////////////////////////////
//
// printTears --
//

function printTears(analysis) {
	var output = "";

	if (!analysis.TEARS) {
		return output;
	}
	var treble_tears = analysis.TEARS.TREBLE_TEARS;
	var bass_tears = analysis.TEARS.BASS_TEARS;
	if (treble_tears) {
		treble_tears = treble_tears.TEAR;
	}
	if (bass_tears) {
		bass_tears = bass_tears.TEAR;
	}
	if (treble_tears && !Array.isArray(treble_tears)) {
		treble_tears = [ treble_tears ];
	}
	if (bass_tears && !Array.isArray(bass_tears)) {
		bass_tears = [ bass_tears ];
	}
	var tears = [];
	if (treble_tears) {
		tears = tears.concat(treble_tears);
	}
	if (bass_tears) {
		tears = tears.concat(bass_tears);
	}

	var iw = parseInt(analysis.IMAGE_WIDTH);
	var x, y, w, h;
	var tearcolor = "#ff00ff";
	for (var i=0; i<tears.length; i++) {
		w = parseInt(tears[i].WIDTH_ROW);
		h = parseInt(tears[i].WIDTH_COL);
		x = parseInt(tears[i].ORIGIN_ROW);
		y = iw - parseInt(tears[i].ORIGIN_COL) - h;
		// display tear more visibly in view if too small:
		if (w < 50) { w = 50; }
		if (h < 50) { h = 50; }
		output += addRect(x, y, w, h, tearcolor);
	}

	return output;
}



//////////////////////////////
//
// addCircle --
//

function addCircle(cx, cy, radius, fillcolor) {
	var output = "";
	output += "<circle cx='";
	output += cx;
	output += "' cy='";
	output += cy;
	output += "' r='";
	output += radius;
	output += "' style='";
	output += "fill:" + fillcolor;
	output += "'/>\n";
	return output;
}



//////////////////////////////
//
// addPolygon --
//

function addPolygon(path, fillcolor) {
	var output = "";
	output += "<polygon points='";
	output += path;
	output += "' ";
	output += "style='"
	output += "fill: ";
	output += fillcolor;
	output += "'";
	output += "/>\n";
	return output;
}



//////////////////////////////
//
// addRect --
//

function addRect(x, y, w, h, fillcolor, strokecolor, parameter) {
	var output = "";
	output += " <rect x='";
	output += x;
	output += "' y='";
	output += y;
	output += "' width='";
	output += w;
	output += "' height='";
	output += h;
	output += "'";
	output += " style='";
	if (fillcolor) {
		output += " fill: ";
		output += fillcolor;
		output += ";";
	}
	if (strokecolor) {
		output += " stroke: ";
		output += strokecolor;
		output += ";";
	}
	output += "'";
	if (parameter) {
		output += " ";
		output += parameter;
	}
	output += "/>\n";
	return output;
}



//////////////////////////////
//
// displayTearAnalysis --
//

function displayTearAnalysis(analysis) {
	console.log("ANALYSIS", analysis);
	var output = "";

	var druid = DRUID;
	var element = document.querySelector("#tear");
	if (!element) {
		setContents("#etears", 0);
		return;
	}
	var tears = analysis.TEARS;
	if (!tears) {
		output += "<p>";
		output += "There are no significant edge tears on the roll.";
		output += "</p>";
		element.innerHTML = output;
		setContents("#etears", 0);
		return;
	}
	var treble_tears = tears.TREBLE_TEARS;
	var bass_tears = tears.BASS_TEARS;
	if ((!bass_tears) && (!treble_tears)) {
		output += "<p>";
		output += "There are no significant edge tears on roll";
		output += "</p>";
	}
	if (bass_tears) {
		output += displayTearListBass(druid, analysis, bass_tears);
	}
	if (treble_tears) {
		output += displayTearListTreble(druid, analysis, treble_tears);
	}
	setContents("#etears", TEARTREBLECOUNT + TEARBASSCOUNT);
	element.innerHTML = output;
}



//////////////////////////////
//
// displayShiftAnalysis --
//

function displayShiftAnalysis(analysis) {
	console.log("ANALYSIS", analysis);
	var output = "";

	var druid = DRUID;
	var element = document.querySelector("#shifts");
	if (!element) {
		setContents("#oshifts", 0);
		return;
	}
	var shifts = analysis.SHIFTS;
	if (!shifts) {
		output += "<p>";
		output += "No operator shifts were detected on the roll.";
		output += "</p>";
		element.innerHTML = output;
		setContents("#oshifts", 0);
		return;
	}
	if (shifts == 0) {
		output += "<p>";
		output += "No operator shifts were detected on the roll.";
		output += "</p>";
		element.innerHTML = output;
		setContents("#oshifts", 0);
		return;
	}
	shifts = shifts[1].SHIFT;

	if (!Array.isArray(shifts)) {
		shifts = [ shifts ];
	}

	output += displayShiftList(druid, analysis, shifts);
	element.innerHTML = output;
}



//////////////////////////////
//
// displayShiftList --
//

function displayShiftList(druid, analysis, shifts) {
	console.log("MMMMMMMMMMMMMM", shifts);
	var output = "";

	var stext = shifts.length;
	if (shifts.length == 1) {
		output += "<p>There is one shift on the roll.";
		output += " The shift is centered vertically in the image.";
		output += " Scroll right in the image below to view the right side of the roll.";
		output += "</p>";
		stext += " (";
		stext += shifts[0].MOVEMENT;
		stext += ")";
	} else {
		output += "<p>There are " + shifts.length  + " shifts on the roll.  The following list of the shifts are sorted by size (largest first).";
		output += " The shifts are centered vertically in the images.";
		output += " Scroll right in the images below to view the right sides of the rolls.";
		output += "</p>";
		stext += " (max shift ";
		stext += shifts[0].MOVEMENT;
		stext += ")";
	}
	
	setContents("#oshifts", stext);

	output += "<table class='tear'>";

	var url;
	var x;
	var y;
	var dx;
	var dy;
	var boundingbox;

	var topmargin    = 300;
	var bottommargin = 300;

	for (var i=0; i<shifts.length; i++) {
		var sift = shifts[i];
		url = "https://stacks.stanford.edu/image/iiif/" + druid;
		url += "%2F" + druid + "_0001/";
		// x,y,dx,dy
		x  = 0;
		y  = parseInt(sift.ROW) - topmargin;
		dx = 4096;
		dy = topmargin + bottommargin;
		boundingbox = x + "," + y + "," + dx + "," + dy;
		url += x + "," + y + "," + dx + "," + dy;
		url += "/pct:75/0/default.jpg";

		output += "<tr>";
		output += "<td style='vertical-align:top;'>";
		output += "<table>";

		output += "<tr><td>";
		output += "<b>Hole ID:</b></td><td>" + sift.ID + "<br/>";
		output += "</td></tr>";

		output += "<tr><td>";
		output += "<b>Shift:</b></td><td>" + sift.MOVEMENT + "<br/>";
		output += "</td></tr>";

		output += "<tr><td>";
		var feet = parseInt(sift.ROW) / 300.25 / 12;
		feet = parseInt(feet * 10.0 + 0.5)/10.0;
		output += "<b>Position:</b></td><td>" + feet + " feet (from beginning of image)<br/>";
		output += "</td></tr>";

		output += "<tr><td>";
		output += "<b>Bounding&nbsp;box:</b></td><td>" + boundingbox + " (pixels)<br/>";
		output += "</td></tr>";

		output += "</table>";
		output += "</td></tr>";

		output += "<tr>";
		output += "<td>";
		output += "<div class='scroll'>";
		output += "<img src='" + url + "'>";
		output += "</div>";
		output += "</td>";
		output += "</tr>";
	}

	output += "</table>";
	return output;
}



//////////////////////////////
//
// setContents --
//

function setContents(selector, value) {
	var element = document.querySelector(selector);
	if (!element) {
		return;
	}
	element.innerHTML = value;
}



//////////////////////////////
//
// displayHoleAnalysis --
//

function displayHoleAnalysis(analysis) {
	console.log("ANALYSIS", analysis);
	var output = "";

	var druid = DRUID;
	var element = document.querySelector("#holes");
	if (!element) {
		setContents("#sholes", 0);
		return;
	}
	var holes = analysis.BADHOLES;
	if (!holes) {
		output += "<p>";
		output += "There are no suspicious holes on the roll.";
		output += "</p>";
		element.innerHTML = output;
		setContents("#sholes", 0);
		return;
	}
	holes = holes.HOLE;

	if (!Array.isArray(holes)) {
		holes = [ holes ];
	}

	output += displayHoleList(druid, analysis, holes);
	element.innerHTML = output;
}



//////////////////////////////
//
// displayHoleList --
//

function displayHoleList(druid, analysis, holes) {
	console.log("MMMMMMMMMMMMMM", holes);
	var output = "";

	if (holes.length == 1) {
		output += "<p>There is one suspicious hole on the roll.";
		output += "  Not all suspicious holes are bad, and not all bad holes are marked as suspicious (but probably most are).";
		output += "</p>";
	} else {
		output += "<p>There are " + holes.length  + " suspicious holes on the roll.";
		output += "  Not all suspicious holes are bad, and not all bad holes are marked as suspicious (but probably most are).";
		output += "</p>";
	}
	setContents("#sholes", holes.length);

	output += "<table class='tear'>";

	var url;
	var x;
	var y;
	var dx;
	var dy;
	var boundingbox;

	var rightmargin  = 50;
	var leftmargin   = 50;
	var topmargin    = 50;
	var bottommargin = 50;

	for (var i=0; i<holes.length; i++) {
		var hole = holes[i];
		url = "https://stacks.stanford.edu/image/iiif/" + druid;
		url += "%2F" + druid + "_0001/";
		// x,y,dx,dy
		x  = parseInt(hole.ORIGIN_COL) - leftmargin;
		y  = parseInt(hole.ORIGIN_ROW) - topmargin;
		dx = parseInt(hole.WIDTH_COL) + rightmargin + leftmargin;
		dy = parseInt(hole.WIDTH_ROW) + topmargin + bottommargin;
		boundingbox = x + "," + y + "," + dx + "," + dy;
		url += x + "," + y + "," + dx + "," + dy;
		url += "/pct:100/0/default.jpg";
		output += "<tr>";

		output += "<td>";
		output += "<img src='" + url + "'><br/>";
		output += "</td><td style='vertical-align:top;'>";
		output += "<table>";

		output += "<tr><td>";
		output += "<b>Hole ID:</b></td><td>" + hole.ID + "<br/>";
		output += "</td></tr>";

		output += "<tr><td>";
		output += "<b>Reason:</b></td><td>" + hole.REASON + "<br/>";
		output += "</td></tr>";

		output += "<tr><td>";
		var areamm = parseInt(hole.AREA) / 90000 * 645.16;
		areamm = parseInt(areamm * 10.0 + 0.5)/10.0;
		output += "<b>Area:</b></td><td>" + areamm + " mm<sup>2</sup><br/>";
		output += "</td></tr>";

		output += "<tr><td>";
		var depthmm = parseInt(hole.WIDTH_COL) / 300 * 25.4;
		depthmm = parseInt(depthmm * 10.0 + 0.5)/10.0;
		output += "<b>Depth:</b></td><td>" + depthmm + " mm<br/>";
		output += "</td></tr>";

		output += "<tr><td>";
		var feet = parseInt(hole.ORIGIN_ROW) / 300.25 / 12;
		feet = parseInt(feet * 10.0 + 0.5)/10.0;
		output += "<b>Position:</b></td><td>" + feet + " feet (from beginning of image)<br/>";
		output += "</td></tr>";

		output += "<tr><td>";
		output += "<b>Bounding&nbsp;box:</b></td><td>" + boundingbox + " (pixels)<br/>";
		output += "</td></tr>";

		output += "</table>";
		output += "</td></tr>";
	}

	output += "</table>";
	return output;
}



//////////////////////////////
//
// displayTearListBass --
//
// <img src="https://stacks.stanford.edu/image/iiif/jc718cb5784%2Fjc718cb5784_0001/0,20000,1500,1500/pct:50/0/default.jpg">
//

function displayTearListBass(druid, analysis, tears) {
	console.log("YYYYYYYYYYYYYYY", tears);
	console.log("XXXXXXXXXXXXX", tears.TEAR);
	var output = "";

	var tearlist = tears.TEAR;
	if (!Array.isArray(tearlist)) {
		tearlist = [ tearlist ];
	}

	if (tearlist.length == 1) {
		output += "<p>There is one tear on the bass side of the roll.</p>";
	} else {
		output += "<p>There are " + tearlist.length  + " tears on the bass side of the roll.  The following list of tears is sorted by the size of the tear, from largest to smallest.</p>";
	}
	TEARBASSCOUNT = tearlist.length;

	output += "<table class='tear'>";

	var url;
	var x;
	var y;
	var dx;
	var dy;
	var boundingbox;

	var rightmargin = 300;
	var topmargin = 100;
	var bottommargin = 100;

	for (var i=0; i<tearlist.length; i++) {
		var tear = tearlist[i];
		url = "https://stacks.stanford.edu/image/iiif/" + druid;
		url += "%2F" + druid + "_0001/";
		// x,y,dx,dy
		x  = parseInt(tear.ORIGIN_COL);
		y  = parseInt(tear.ORIGIN_ROW) - topmargin;
		dx = parseInt(tear.WIDTH_COL) + rightmargin;
		dy = parseInt(tear.WIDTH_ROW) + topmargin + bottommargin;
		boundingbox = x + "," + y + "," + dx + "," + dy;
		url += x + "," + y + "," + dx + "," + dy;
		url += "/pct:50/0/default.jpg";
		output += "<tr>";

		output += "<td>";
		output += "<img src='" + url + "'><br/>";
		output += "</td><td style='vertical-align:top;'>";
		output += "<table>";

		output += "<tr><td>";
		output += "<b>Tear ID:</b></td><td>" + tear.ID + "<br/>";
		output += "</td></tr>";

		output += "<tr><td>";
		var areamm = parseInt(tear.AREA) / 90000 * 645.16;
		areamm = parseInt(areamm * 10.0 + 0.5)/10.0;
		output += "<b>Area:</b></td><td>" + areamm + " mm<sup>2</sup><br/>";
		output += "</td></tr>";

		output += "<tr><td>";
		var depthmm = parseInt(tear.WIDTH_COL) / 300 * 25.4;
		depthmm = parseInt(depthmm * 10.0 + 0.5)/10.0;
		output += "<b>Depth:</b></td><td>" + depthmm + " mm<br/>";
		output += "</td></tr>";

		output += "<tr><td>";
		var feet = parseInt(tear.ORIGIN_ROW) / 300.25 / 12;
		feet = parseInt(feet * 10.0 + 0.5)/10.0;
		output += "<b>Position:</b></td><td>" + feet + " feet (from beginning of image)<br/>";
		output += "</td></tr>";

		output += "<tr><td>";
		output += "<b>Bounding&nbsp;box:</b></td><td>" + boundingbox + " (pixels)<br/>";
		output += "</td></tr>";

		output += "</table>";
		output += "</td></tr>";
	}

	output += "</table>";
	return output;
}



//////////////////////////////
//
// displayTearListTreble --
//
// <img src="https://stacks.stanford.edu/image/iiif/jc718cb5784%2Fjc718cb5784_0001/0,20000,1500,1500/pct:50/0/default.jpg">
//   /0,20000,1500,1500/pct:50/0/default.jpg">
//

function displayTearListTreble(druid, analysis, tears) {
	console.log("YYYYYYYYYYYYYYY", tears);
	console.log("XXXXXXXXXXXXX", tears.TEAR);
	var output = "";

	var tearlist = tears.TEAR;
	if (!Array.isArray(tearlist)) {
		tearlist = [ tearlist ];
	}

	if (tearlist.length == 1) {
		output += "<p>There is one tear on the treble side of the roll.</p>";
	} else {
		output += "<p>There are " + tearlist.length  + " tears on the treble side of the roll.  The following list of tears is sorted by the size of the tear, from largest to smallest.</p>";
	}
	TEARTREBLECOUNT = tearlist.length;

	output += "<table class='tear'>";

	var url;
	var x;
	var y;
	var dx;
	var dy;
	var boundingbox;

	var leftmargin = 300;
	var topmargin = 100;
	var bottommargin = 100;

	for (var i=0; i<tearlist.length; i++) {

		var tear = tearlist[i];
		url = "https://stacks.stanford.edu/image/iiif/" + druid;
		url += "%2F" + druid + "_0001/";
		// x,y,dx,dy
		x  = parseInt(tear.ORIGIN_COL) - leftmargin;
		y  = parseInt(tear.ORIGIN_ROW) - topmargin;
		dx = parseInt(tear.WIDTH_COL) + leftmargin;
		dy = parseInt(tear.WIDTH_ROW) + topmargin + bottommargin;
		boundingbox = x + "," + y + "," + dx + "," + dy;
		url += x + "," + y + "," + dx + "," + dy;
		url += "/pct:50/0/default.jpg";

		output += "<tr>";

		output += "<td style='vertical-align:top;'>";
		output += "<table>";

		output += "<tr><td>";
		output += "<b>Tear ID:</b></td><td>" + tear.ID + "<br/>";
		output += "</td></tr>";

		output += "<tr><td>";
		var areamm = parseInt(tear.AREA) / 90000 * 645.16;
		areamm = parseInt(areamm * 10.0 + 0.5)/10.0;
		output += "<b>Area:</b></td><td>" + areamm + " mm<sup>2</sup><br/>";
		output += "</td></tr>";

		output += "<tr><td>";
		var depthmm = parseInt(tear.WIDTH_COL) / 300 * 25.4;
		depthmm = parseInt(depthmm * 10.0 + 0.5)/10.0;
		output += "<b>Depth:</b></td><td>" + depthmm + " mm<br/>";
		output += "</td></tr>";

		output += "<tr><td>";
		var feet = parseInt(tear.ORIGIN_ROW) / 300.25 / 12;
		feet = parseInt(feet * 10.0 + 0.5)/10.0;
		output += "<b>Position:</b></td><td>" + feet + " feet (from beginning of image)<br/>";
		output += "</td></tr>";

		output += "<tr><td>";
		output += "<b>Bounding&nbsp;box:</b></td><td>" + boundingbox + " (pixels)<br/>";
		output += "</td></tr>";

		output += "</table>";
		output += "</td>";

		output += "<td>";
		output += "<img src='" + url + "'><br/>";
		output += "</td>";

		output += "</tr>";
	}

	output += "</table>";
	return output;
}



//////////////////////////////
//
// displayDriftAnalysisOld --
//

function displayDriftAnalysisOld(analysis) {
	if (!analysis.DRIFT) {
		return;
	}
	var dstring = analysis.DRIFT.DATA;
	if (!dstring) {
		return;
	}

	var datalines = dstring.split(/\r?\n/);
	var jj = "";
	var pixel, drift;
	var first = 1;
	jj += '{\n';
	jj += '"$schema": "https://vega.github.io/schema/vega-lite/v3.0.0-rc12.json",\n';
	jj += '"width": 1000,\n';
	jj += '"description": "Drift analysis",\n';
	jj += '"data": {\n';
	jj += '	"values": [\n';

	for (var i=0; i<datalines.length; i++) {
		if (!first) {
			jj += ",\n";
		}
		first = 0;
		data = datalines[i].replace(/^\s+/, "").split("\t");
		pixel = parseInt(data[0]);
		drift = parseFloat(data[1]);
		jj += '{"feet": ' + (pixel/300/12) + ', "drift": ' + drift + '}';
	}
	
	jj += '	]},\n';
	jj += '  "mark": "line",\n';
	jj += '  "encoding": {\n';
	jj += '    "x": {"field": "feet", "type": "quantitative"},\n';
	jj += '    "y": {"field": "drift", "type": "quantitative"}\n';
	jj += '  }\n';
	jj += '}\n';

	var mydata = JSON.parse(jj);
	vegaEmbed("#drift", mydata);
}



//////////////////////////////
//
// displayHoleHistogram --
//


function displayHoleHistogram(analysis, region) {
	if (!analysis.DEBUGGING) {
		return;
	}
	if (!analysis.DEBUGGING.HOLE_HISTOGRAM) {
		return;
	}

	var histtext = analysis.DEBUGGING.HOLE_HISTOGRAM;
	var histlist = histtext.split(/\r?\n/);

	var found = 0;
	var jj = "";

	jj += '{\n';
	jj += '  "$schema": "https://vega.github.io/schema/vega-lite/v3.0.0-rc12.json",\n';
	jj += '  "title": "Hole centroid distributions before and after drift correction",\n';
	jj += '    "layer": [{\n';
	jj += '\n';
	jj += '	"data": {\n';
	jj += '		"values": [\n';

	var data;
	var first = 1;
	var max = 512;
	for (var i=region*max; i<(region+1)*max; i++) {
		data = histlist[i].split(/\t/);
		if (!first) {
			jj += ",\n";
		}
		jj += '{"category": "' + i  + '",\t';
		jj += '"count": ' + data[1] + ',\t';
		jj += '"countB": ' + data[2] + '}';
		first = 0;
	}

	//		{"category": "-7",  "count": 0,   "countB": 0},
	//		{"category": "-6",  "count": 10,  "countB": 0},
	//		{"category": "-5",  "count": 12,  "countB": 0},
	//		{"category": "-4",  "count": 15,  "countB": 0},
	//		{"category": "-3",  "count": 19,  "countB": 0},
	//		{"category": "-2",  "count": 39,  "countB": 0},

	jj += '		]},\n';
	jj += '\n';
	jj += '      "layer": [{\n';
	jj += '        "mark": "bar",\n';
	jj += '        "encoding": {\n';
	jj += '          "x": {"field": "category", "type": "ordinal", "axis": {"labelAngle": 90}, "sort": "count"},\n';
	jj += '          "y": {"field": "count", "type": "quantitative"}\n';
	jj += '        }\n';
	jj += '      }, {\n';
	jj += '        "mark": {"type": "bar", "opacity":0.7},\n';
	jj += '        "encoding": {\n';
	jj += '          "x": {"field": "category", "title": "pixel (0 indicates final position assignment of hole position for a pitch)", "type": "ordinal", "sort": "count"},\n';
	jj += '          "y": {"field": "countB", "title": "hole count", "type": "quantitative"},\n';
	jj += '          "color": {"value": "#dd0044"}\n';
	jj += '        }\n';
	jj += '      }\n';
	jj += '    ]}\n';
	jj += '  ]\n';
	jj += '}\n';

	var mydata = JSON.parse(jj);
	vegaEmbed("#hole-histogram-" + region, mydata);
}


//////////////////////////////
//
// displayPrevDruid --
//

function displayPrevDruid() {
	var entry = DRUIDINFO[DRUID];
	if (!entry) {
		return;
	}
	DRUID = entry.prev;
	document.body.style.cursor = "wait";
	clearReport();
	displayReport(DRUID);
}



//////////////////////////////
//
// displayNextDruid --
//

function displayNextDruid() {
	var entry = DRUIDINFO[DRUID];
	if (!entry) {
		return;
	}
	DRUID = entry.next;
	document.body.style.cursor = "wait";
	clearReport();
	displayReport(DRUID);
}


//////////////////////////////
//
// clearReport --
//

function clearReport() {
	var element;

	setContents("#sholes", "");
	setContents("#oshifts", "");
	setContents("#etears", "");

	element = document.querySelector("#tear");
	if (element) {
		element.innerHTML = "";
	}

	element = document.querySelector("#info");
	if (element) {
		element.innerHTML = "";
	}

	element = document.querySelector("#drift");
	if (element) {
		element.innerHTML = "";
	}

	element = document.querySelector("#holes");
	if (element) {
		element.innerHTML = "";
	}

	element = document.querySelector("#shifts");
	if (element) {
		element.innerHTML = "";
	}



}


//////////////////////////////
//
// buildDruidIndex --
//

function buildDruidIndex(rollinfo) {
	DRUIDINFO = {};
	var druid;
	var druidnext;
	var druidprev;
	var obj;
	for (var i=1; i<rollinfo.length - 1; i++) {
		druid = rollinfo[i].DRUID;
		druidnext = rollinfo[i+1].DRUID;
		druidprev = rollinfo[i-1].DRUID;
		DRUIDINFO[druid] = {
			info: rollinfo[i],
			curr: druid,
			next: druidnext,
			prev: druidprev
		};
	}

	// and endpoints

	DRUIDINFO[rollinfo[0].DRUID] = {
		info: rollinfo[0],
		curr: rollinfo[0].DRUID,
		next: rollinfo[1].DRUID,
		prev: rollinfo[rollinfo.length-1].DRUID
	};

	DRUIDINFO[rollinfo[rollinfo.length-1].DRUID] = {
		info: rollinfo[rollinfo.length-1],
		curr: rollinfo[rollinfo.length-1].DRUID,
		next: rollinfo[0].DRUID,
		prev: rollinfo[rollinfo.length-2].DRUID
	};
}



//////////////////////////////
//
// displayDriftAnalysis --
//

function displayDriftAnalysis() {
	druid = DRUID;
	console.log("DRUID = ", druid);
	if (!druid) {
		return;
	}

	var letter = druid.charAt(0);
	var prefix = "https://supra.stanford.edu/drift/";
	var file = prefix + "data/" + letter + "/" + druid + "_drift.json";

	var firsthole = info.FIRST_HOLE;
	if (firsthole) {
		firsthole = parseInt(firsthole);
		// var calc = "(datum.r - " + firsthole  + ")/12.0/300.25";
		var calc = "datum.r/12.0/300.25";
		PLOT.transform[0].calculate = calc;
	}

	PLOT.data.url = file;

	vegaEmbed("#drift", PLOT);

}



//////////////////////////////
//
// displayInfo --
//

function displayInfo() {
	var druid = DRUID;
	var info = DRUIDINFO[druid].info;
	if (!info) {
		return;
	}
	var element = document.querySelector("#info");
	if (!element) {
		return;
	}

	var available = 1;
	if (!info.DRIFT_RANGE) {
		available = 0;
	}

	var feet;
	var meter;

	var output = "";
	output += "<table class='info'>";

	output += "<tr>";
	output += "<td>";
	output += "<b>Label:</b>";
	output += "<td>";
	output += "<td>";
	output += info.LABEL;
	output += "<td>";
	output += "</tr>";

	output += "<tr>";
	output += "<td>";
	output += "<b>Title:</b>";
	output += "<td>";
	output += "<td>";
	output += info.TITLE;
	output += "<td>";
	output += "</tr>";

	output += "<tr>";
	output += "<td>";
	output += "<b>Composer:</b>";
	output += "<td>";
	output += "<td>";
	output += info.COMPOSER;
	output += "<td>";
	output += "</tr>";

	output += "<tr>";
	output += "<td>";
	output += "<b>Performer:</b>";
	output += "<td>";
	output += "<td>";
	output += info.PERFORMER;
	output += "<td>";
	output += "</tr>";

	output += "<tr>";
	output += "<td>";
	output += "<b>Edge&nbsp;tears:</b>";
	output += "<td>";
	output += "<td>";
	output += "<span id='etears'></span>";
	output += "<td>";
	output += "</tr>";

	output += "<tr>";
	output += "<td>";
	output += "<b>Suspicious&nbsp;holes:</b>";
	output += "<td>";
	output += "<td>";
	output += "<span id='sholes'></span>";
	output += "<td>";
	output += "</tr>";

	output += "<tr>";
	output += "<td>";
	output += "<b>Operator&nbsp;shifts:</b>";
	output += "<td>";
	output += "<td>";
	output += "<span id='oshifts'></span>";
	output += "<td>";
	output += "</tr>";

	output += "</table>";
	element.innerHTML = output;
}


</script>



